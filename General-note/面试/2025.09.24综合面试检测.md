# 1.第二个项目的性能优化再系统性的说一下

我们首先通过 Chrome DevTools 的 Performance 面板以及 Google Lighthouse 进行性能分析，定位到几个关键问题：首屏加载时间过长，FCP（First Contentful Paint）指标偏高；页面交互卡顿，尤其是在渲染大数据列表时；路由切换时存在明显的白屏和延迟；React 架构下存在重复渲染和不必要的状态更新。

针对不同场景，我们采取了有针对性的优化措施：
首屏加载优化：聚焦 FCP 指标，采用资源预加载（preload）、压缩图片、减少阻塞脚本等方式；精简首屏渲染内容，延迟加载非关键模块。
大列表渲染优化：引入虚拟滚动（如 react-window）和分页机制，避免一次性渲染全部数据；对数据请求做了缓存处理，提升滚动流畅度。
路由性能优化：使用 React 的 lazy 和 Suspense 实现路由组件的按需加载；对路由切换过程中的设置loading动画，提升用户体验。
React 架构代码优化：使用 useMemo 和 useCallback 避免不必要的函数和组件重渲染；精细化组件拆分，提升可维护性和渲染效率；

另外，我们还在构建层面做了优化，项目是基于 Vite 的，所以我们利用它的 Tree Shaking 特性，把没用到的代码自动剔除掉，减小了打包体积。

# 2.虚拟列表的滚动过快导致的白屏问题如何解决
通过阅读ANTD负责人的一篇文档，他提到不同于触摸板与滚轮场景，直接拖拽滚动条是无法拦截的。为此，我们设置 `overflow: hidden` 直接隐藏滚动条，并额外实现了一个“假的”滚动条来代替原生的。利用这个滚动条，就可以做到每次拖拽会先经过我们的虚拟滚动逻辑，再进行滚动操作：每次计算时，都通过滚动条所在位置的百分比还原回 scrollTop 的值。

# 3.第二个项目的权限管理再熟悉一下

在这个项目里，我们的权限管理是基于 RBAC（角色访问控制）模型来设计的。用户登录后，我们会通过 JWT 做身份验证，拿到 token 后把用户的角色信息存到 Redux 状态里，配合 RTK 做统一管理。这样我们就可以在前端根据角色动态控制页面展示和功能权限。

在路由层面，我们用了 react-router 的路由守卫机制，封装了一个高阶组件，可以根据用户角色判断是否有权限访问某个页面。如果没有权限，就自动跳转到 403 页面或者登录页。同时我们还封装了一个自定义 hook，用来在组件内部判断当前用户是否具备某个操作权限，比如按钮是否显示、表单是否可编辑等。

整个权限系统是动态的，路由表也是根据用户角色来生成的，这样可以做到按需加载、提升性能，也方便后期扩展。这个方案在实际项目中运行得很稳定，也让我们在多人协作和权限变更时更容易维护。