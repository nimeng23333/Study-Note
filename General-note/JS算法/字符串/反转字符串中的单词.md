---
title: 反转字符串中的单词
---
力扣 557反转字符串中的单词、696计数二进制子串

# 正则表达式：
`\s` ：空格

`\S` ：非空格，不包括换行

 `[\w']+` ：单词 
 - `\w`：匹配字母、数字或下划线，等同于 `[a-zA-Z0-9_]`。
- `'`：匹配单引号字符。
- `[]`：字符类，匹配其中任意一个字符。
- `+`：表示前面的模式可以重复一次或多次。
因此，`[\w']+` 可以匹配如 `hello`、`world's`、`123` 或 `user_name` 等字符串。

`\w `：匹配字母、数字、下划线。等价于` [A-Za-z0-9_]`

`/^/` ：字符串开头
`/^((0+)|(1+))/` ：字符串开头的连续多个0或1

修饰符
g ：查找所有
m 边界字符 ^ 和$匹配每一行的开头和结尾

正则表达式中中括号是可选项

01取反：let revert = string ^ 1 (本质是与1的异或运算)


[696. 计数二进制子串](https://leetcode.cn/problems/count-binary-substrings/)

给定一个字符串 `s`，统计并返回具有相同数量 `0` 和 `1` 的非空（连续）子字符串的数量，并且这些子字符串中的所有 `0` 和所有 `1` 都是成组连续的。

重复出现（不同位置）的子串也要统计它们出现的次数。

 

**示例 1：**

**输入：** s = "00110011"
**输出：** 6
**解释：** 6 个子串满足具有相同数量的连续 1 和 0 ："0011"、"01"、"1100"、"10"、"0011" 和 "01" 。
注意，一些重复出现的子串（不同位置）要统计它们出现的次数。
另外，"00110011" 不是有效的子串，因为所有的 0（还有 1 ）没有组合在一起。

**示例 2：**

**输入：** s = "10101"
**输出：** 4
**解释：** 有 4 个子串："10"、"01"、"10"、"01" ，具有相同数量的连续 1 和 0 。

```js
var countBinarySubstrings = function(s) {
    let count = 0;
    function matchStr (subStr){
        let start = subStr.match(/^((0+)|(1+))/)[0]; //正则表达式开头连续的0或1
        let matchS = start + (start[0] ^ 1).toString().repeat(start.length);
        //需要匹配的内容为start + 0或1的反转*开头连续次数。 ^ 1 是异或运算，与1的异或运算，0 1 = 1， 1 1 = 0
        return subStr.startsWith(matchS)
    }

    for(let i=0; i< s.length-1; i++){
        let subS = s.substring(i)
        if(matchStr(subS)){
            count++
        }
    }
    return count
};
```
但超时了，官方题解有个更变态的解法

思路：
00111001观察字符串，将字符串变为一个数组`[2,3,2,1]`也就是每一个数字连续出现的次数，存成一个新的数组。
对于前5个数字`[2,3]`可以组成的有01、0011两个，也就是2和3之间的小值。
因此遍历数组，取i和i+1的最小值，相加，即可得到答案。
```js
var countBinarySubstrings = function(s) {

    let count = [];

    let result = 0;

    let sub = s.match(/(0+|1+)/g)

    for(let i = 0; i<sub.length; i++){

        count.push(sub[i].length)

    }

    for(let i = 0; i< count.length -1; i++){

        result += Math.min(count[i],count[i+1])

    }  

    return result

}
```