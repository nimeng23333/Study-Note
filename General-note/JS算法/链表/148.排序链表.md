---
title: 148.排序链表
---
排序算法包括归并排序、堆排序和快速排序（快速排序的最差时间复杂度是 O(n2)），其中最适合链表的排序算法是归并排序。

[链表问题：虚拟节点dummy - 知乎](https://zhuanlan.zhihu.com/p/143111832)

sort本身是快排，且只能用于数组，不能用于链表

思路
看到时间复杂度的要求，而且是链表，归并排序比较好做。
都知道归并排序要先归（二分），再并。两个有序的链表是比较容易合并的。
二分到不能再二分，即递归压栈压到链只有一个结点（有序），于是在递归出栈时进行合并。

比如有链表长度是 8，将 8 分成左右各 4 个，再将 4 个分成左右各 2 个，再将 2 个分成左右各 1 个，数量为 1 以后，再 return 回去左右两个链表合并排序后的结果

即归并是从中间开始不断分为左右两部分，对左右两部分进行合并排序。

伪代码
```js
func sortList (head) {
	对链表进行二分
	l = sortList(左链) // 已排序的左链
	r = sortList(右链) // 已排序的右链
	merged = mergeList(l, r) // 进行合并
	return merged		// 返回合并的结果给父调用
}
```

# 链表
链表结构其实是内存内部的一种存储方式，链表则是把一系列节点串联起来，每个节点上至少包含两个部分： **数据域** 与 **指针域**

数据：保存数据

指针：指向下一个节点的引用

链表中的每个节点，通过指针域的值，形成一个线性结构

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e102c23e614d48adbdd4a24c89cc0c0f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

### 2. 链表的优缺点

因为链表是一种 **松散** 的结构体，所以当你想要找到其中的某一个节点时，只能够从 **头节点** 一级一级的往下找，但也因为这种松散的结构使得其进行 **插入** 和 **删除** 时只需要改变其 **指针域** 的指向即可

优点：适合动态插入和删除的应用场景 缺点：不能快速的定位和随机访问数据


```js
var sortList = function(head) {

    if(head === null || head.next === null){
        return head //链表为空或只有一个节点的情况，不需要排序及拆分
    }

    let head2 = middleNode(head);
    head = sortList(head);
    head2 = sortList(head2);
    return mergeNode(head,head2)
};
  

//寻找中间节点
function middleNode(head){
    let pre = head, slow = head, fast = head;
    while(fast && fast.next){
        pre = slow;
        slow = slow.next;
        fast = fast.next.next;
    }
    pre.next = null;
    return slow
}
  

//合并两个有序链表
function mergeNode(list1,list2){
    const dummy = new ListNode();
    let cur = dummy;
    while(list1 && list2){
        if(list1.val < list2.val){
            cur.next = list1;
            list1 = list1.next;
        }else{
            cur.next = list2;
            list2 = list2.next;
        }
        cur = cur.next
    }
    cur.next = list1 ?? list2
    return dummy.next
}
```