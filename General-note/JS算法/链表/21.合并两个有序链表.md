---
title: 21.合并两个有序链表
---
将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)

**输入：**` l1 = [1,2,4], l2 = [1,3,4]`
**输出：**`[1,1,2,3,4,4]`

**示例 2：**

**输入：** `l1 = [], l2 = []`
**输出：**`[]`

**示例 3：**

**输入：**` l1 = [], l2 = [0]`
**输出：**` [0]`


前置：
dummy node 虚拟节点，又叫哨兵。创建一个哨兵节点，作为合并后的新链表头节点的前一个节点。这样可以避免单独处理头节点，也无需特判链表为空的情况，从而简化代码。
88题合并两个有序数组


```js
var mergeTwoLists = function(list1, list2) {
    const dummy = new ListNode();
    let cur = dummy; //cur指向dummy链尾
    while(list1 && list2){
        if(list1.val < list2.val){ //判断list1当前节点的值与list2当前节点的值
            cur.next = list1; //dummy链尾接list1当前节点head
            list1 = list1.next; //list1 head指向下一个节点
        }else{
            cur.next = list2;
            list2 = list2.next
        }
        cur = cur.next
    }
    cur.next = list1 ?? list2 //如果有剩余的链就加进来
    return dummy.next
};
```


## 88. 合并两个有序数组
初始化三个指针 `p1 =m−1` 指向 nums1的末尾，
`p2=n−1` 指向 nums2的末尾，
`p=m+n−1` 指向合并后的数组末尾。 
不断比较` nums 1 [p1]` 和 `nums2[p2]` 的大小，将较大的值放入 `nums 1[p]`。如果` p1≥0` 且` nums1[p1] `更大，那么放入后 p1和p减一，否则 p2和p减一。
注意 `nums1[p1]=nums2 ​[p2 ]` 时放入谁都可以，不妨规定放入 `nums2 ​[p2 ]`。

这样在数组元素都相等的情况下，只需要把 nums2的数据填入nums1中，效率更高。 循环直到 `p2<0`，此时 nums2的所有元素均已填入 nums1。
你可能会想，如果 nums1还有元素没有移动呢？注意到当 nums2都合并到 nums1时，nums1 剩余未移动的元素，它要移动的目标位置就是它自己所处的位置，所以无需移动，合并完毕。
这可以算作一个小优化，比如 `nums  1 ​  =[1,2,3,∗,∗,∗]`,`nums  2 ​  =[4,5,6]`，其实只要把 nums2的所有数都填入nums1 中，合并就已经结束了，即便此时` p1=2` 仍然 `≥0`。  


```js
var merge = function(nums1, m, nums2, n) {
    let p1 = m-1, p2 = n-1, p = m+n-1
    while(p2 > -1){
        if(nums1[p1] > nums2[p2]){
            nums1[p] = nums1[p1]
            p1--;
        }else{
            nums1[p] = nums2[p2];
            p2--;
        }
        p--;
    }
};
```