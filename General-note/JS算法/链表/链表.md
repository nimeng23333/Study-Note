---
title: 链表
---
要存储多个元素,另外一个选择就是链表,
但不同于数组,链表中的元素在内存中不必是连续的空间,
链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用(有些语言称为指针或者连接)组成.

优点:
内存空间不是必须连续的.可以充分利用计算机的内存. 实现灵活的内存动态管理
链表不必在创建时就确定大小,并且大小可以无限的延伸下去.
链表在插入和删除数据时,时间复杂度可以达到O(1).相对数组效率高很多

缺点:
链表访问任何一个位置的元素时,都需要从头开始访问.(无法跳过第一个元素访问任何一个元素).口 无法通过下标直接访问元素,需要从头一个个访问, 直到找到对应的元素

```js
function LinkedList(){
	function Node(data){
		this.data = data
		this.next = null
	}
	this.head = null
	this.length = 0
	LinkedList.prototype.append = function(data){
		const newNode = new Node(data)
		if(this.length === 0){
			this.head = newNode;
		}else{
			let current = this.head;
			while(current.next){
				current = current.next
			}
			current.next = newNode
		}
		this.length += 1
	}
	LinkedList.prototype.toString = function(){
		let listString = ""
		let current = this.head
		while(current){
			listString += current.data.toString()
			current = current.next
		}
		return listString
	}
	LinkedList.prototype.insert = function(position,data){
		if(position < 0 || position > this.length){
			return false
		}
		const newNode = new Node(data);
		let current = this.head;
		let previous;
		if(position === 0){
			this.head = newNode;
			this.head.next = current
		}else {
			for(let i = 0; i<position; i++){
				previous = current
				current = current.next
			}
			newNode.next = current;
			previous.next = newNode;
		}
		this.length += 1
		return true
	}
	LinkedList.prototype.get = function(position){
		if(position < 0 || position >= this.length) return null
		let current = this.head;
		for(let i = 0; i< position; i++){
			current = current.next
		}
		return current.data
	}
	LinkedList.prototype.indexOf = function(data){
		let current = this.head;
		let index = 0;
		while(current){
			if(current.data == data) return index
			current = current.next;
			index ++;
		}
		return -1
	}
	LinkedList.prototype.update = function(position,data){
		if(position < 0 || position >= this.length) return false
		let current = this.head;
		for(let i = 0; i< position; i++){
			current = current.next
		}
		current.data = data
		return true
	}
	LinkedList.prototype.removeAt = function(position){
		if(position < 0 || position >= this.length || this.length === 0) return false

		if(position === 0){
			this.head = this.head.next
		}else{
			let current = this.head;
			let previous;
			for(let i = 0; i< position; i++){
				previous = current;
				current = current.next;
			}
			previous.next = current.next
		}

		this.length --
		return true
	}
	LinkedList.prototype.remove = function(data){
		let position = this.indexOf(data);
		return this.removeAt(position)
	}
	LinkedList.prototype.isEmpty = function(){
		if(this.length === 0) return true
		return false
	}
	LinkedList.prototype.size = function(){
		return this.length
	}
}
```

# 链表常见操作

```
append(element) 向队尾添加元素
insert(position,element)
get(position)
indexOf(element)
update(position)
removeAt(position)
remove(element)
isEmpty()
size()
toString()
```