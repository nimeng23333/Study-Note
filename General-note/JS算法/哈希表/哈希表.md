---
title: 哈希表
---
出现冲突的解决办法
1.链地址法
存储的地方已有数据，那么可以用一个数组或者链表
	数组
0      →30→110
1
2      →82→2
3
4       →144→64
5

2.开放地址法
寻找空白的格子来添加

一般是向下一个格子找空白
比如
	数组
0      30
1
2      82
3
4       144
5

要放入32的时候2已经有82了，那么就往82的下一个格子放。

查找的方法：线性探测、二次探测、
### 线性探测
线性探测，先找本来应该在的位置，有数就往后找，直到第一个空格停止。

但删除的时候不能直接将格子设为null
因为比如
	数组
0      30
1
2      82
3      32
4      144
5      62

删除32如果设置为null
在查找62的时候就会报错，可以设置为一个无效值比如-1，保证插入的时候可以插入，但查找的时候不为null

线性探测的问题：
有个严重的问题是聚集
比如插入数据是22 23 24 25 26
这种一连串就是聚集
聚集会影响哈希表性能。
比如插入32的时候要往下找好多格子才能找到空白格子

### 二次探测
在此基础上优化二次探测

优化探测时的步长
线性探测步长是x+1 x+2 x+3
二次探测是 
x + 1^2
x + 2 ^2
x + 3 ^2

但也会造成步长不一的一种聚集

### 再哈希法
虽然下标值一样，但可以根据不同关键字使用不同的探测序列
对关键字进行二次哈希，成为探测步长

第二次哈希化需要具备特点：
和第一个哈希函数不同
且输出不为0

好用的哈希函数：
stepSize = constant - （ key % constant)
其中constant是质数，且小于数组容量
stepSize = 5 - （key % 5)满足需求且不可能为0

## 装填因子
装填因子是已装入的数据和整个哈希表长度的比例
load factor
开放地址法的最大值是1
链地址法可以大于1，可以无限延申下去

实际上使用链地址法的情况更多，js的hashmap就用的链地址法

在开放地址法的效率随着装填因子变高呈指数增长，而链地址法比较平滑的一次函数增长


## 优秀的哈希函数
快速计算+均匀分布
尽量少的乘法除法

多项式得优化法则：霍纳法则

$$ cats = 3*27^3 + 1 * 27^2 + 20* 27 + 17 = 60337 $$ 需要乘法n+n-1+……+1 = n(n+1)/2
需要加法n次

霍纳法则或秦九韶算法快得多
((...(((anx + an-1)x + an - 2)x+ an - 3)...)x + a1 )x + a0
需要n次乘法
n次加法时间复杂度O(N^2)降为O(N)

设计哈希函数
将字符串转为比较大的数字，将大数字压缩到数组范围
```js
 function hashFunc(str,size){
	 let hashCode = 0
	 for(let i = 0; i < str.length; i++){
		 hashCode = 37 * hashCode + str.charCodeAt(i)
	 }//计算大数字
	 let index = hashCode % size //取余
	 return index
 }
```

## 哈希表扩容思想

为什么扩容？
使用链地址法loadFactor可以大于1，但链越长，效率越低，可以考虑在合适的时候扩容。
比较常见的情况是loadFactor大于0.75的时候扩容。

如何扩容？
将容量增大2倍，但这种情况下所有数据项要同步修改，耗时，但如果需要扩容，是必须的

扩容操作：
保存旧数据，重置所有属性
遍历旧数据中的所有bucket，装填进哈希表

判断扩容：
在添加操作的时候判断loadFactor是否大于0.75，大于就扩容2倍
在删除操作的时候判断loadFactor是否小于0.25，小于就缩小容量

## 质数判断

每个数是否是质数可以从2遍历到当前数的平方根，如果可以除尽当前数就不是。因为对一个数进行因数分解，小的一定是小于等于平方根，大的一定是大于等于平方根。比如16 = 2 * 8， 2小于4
```js
function isPrime(num){
	let sqrt = parseInt(Math.sqrt(num))
	for(let i = 2; i< sqrt; i++){
		if(num % i === 0) return false
	}
	return true
}
```

## 哈希表的容量需要为质数
在resize的时候判断当前newSize是否为质数，不是则+1，直到是个质数