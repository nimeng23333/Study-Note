---
title: 101. 对称二叉树
---
二叉树的遍历
【前序遍历】按照 根、左、右 的次序进行遍历

【中序遍历】按照 左、根、右 的次序进行遍历

【后序遍历】按照 左、右、根 的次序进行遍历

 前序遍历

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
  if (root === null) return [];
  // 按前序的次序来存储节点的值
  const ans = [];
  /**
   * 递归遍历树节点
   */
  const traversal = (node) => {
    // 如果该子节点不存在，则终止递归
    if (node === null) return;
    // 处理当前节点
    ans.push(node.val);
    // 处理当前节点的左子树
    traversal(node.left);
    // 处理当前节点的右子树
    traversal(node.right);
  };
  traversal(root);

  return ans;
};
```



中序遍历


// 思路同上，只需将部分代码调整如下

```js
// ...
    // 处理当前节点的左子树
    traversal(node.left);
    // 处理当前节点
    ans.push(node.val);
    // 处理当前节点的右子树
    traversal(node.right);
// ...
```

后序遍历

// 思路同上，只需将部分代码调整如下

```js
// ...
    // 处理当前节点的左子树
    traversal(node.left);
    // 处理当前节点的右子树
    traversal(node.right);
    // 处理当前节点
    ans.push(node.val);
// ...
```

## 递归：

一个树是对称的，那么，它的左右子树是镜像对称的，如下图。
那么，两棵树什么情况下互为镜像呢？
根节点的值相同
一个树的右子树，和另一个树的左子树镜像对称。  
![image.png](https://pic.leetcode-cn.com/1600139802-uMmTVQ-image.png)

```js
var isSymmetric = function(root) {

    if(root === null){
        return true
    }//root不存在return true
    const check = (left,right) =>{
        if(left === null && right === null){
            return true
        }
        if(left && right){
            return left.val === right.val && check(left.left, right.right) && check(left.right, right.left)
        }
        return false //既不是两个都为null也不是两个都存在，那就只存在一个，return false
    }
    return check(root.left, root.right)
};
```

## BFS
```js
var isSymmetric = function(root){
    if(root === null) return true;
    const queue = [];
    queue.push(root.left, root.right);
    while(queue.length){ //queue没被清空的时候进入循环
        for(let i = 0; i< queue.length; i +=2){
            const left = queue.shift();
            const right = queue.shift();
            if((left && right === null) || (right && left === null)) return false;
            if(left && right){
                if(left.val !== right.val) return false;
                queue.push(left.left,right.right)
                queue.push(left.right, right.left)
            }
        }
    }
    return true
}
```