---
title: 二叉树
---
二叉树i层最大节点数 $$ 2^{(i-1)} , i >=1 $$

深度为k的二叉树的最大节点数为$$2^k -1, k >=1$$
对于任何非空二叉树，若n0表示叶节点数，n2表示度为2的非叶节点个数，那么n0 = n2+1

## 二叉树的存储
常见是数组和链表

如果是数组存储
完全二叉树从上到下，从左到右存储
但如果是非完全二叉树需要转成完全二叉树，会造成空间浪费

所以常见还是链表
每个节点封装成node，node中包含存储的数据、左节点、右节点

## 二叉搜索树
二叉搜索树 BST binary search tree
可以为空
如果不为空，需要
非空左子树所有键值小于根节点
非空右子树所有键值大于根节点
左右子树本身也是二叉搜索树

二叉搜索树的数据结构的好处：
二分查找的思想，一定在根节点的左边或右边，而不用找另外一半

## 二叉树遍历

### 先序遍历 preOrderTraversal
1.访问根节点
2.先序遍历左子树
3.先序遍历右子树

handler是如何处理我们的值，可以alert也可以console，也可以拼接字符串然后输出
```js
BinarySearchTree.prototype.preOrderTraversal = function(handler){
	this.preOderTraversalNode(this.root,handler)
}
BinarySearchTree.prototype.preOrderTraversalNode = function(node,handler){
	if(node!==null){
		handler(node.key)
		this.preOrderTraversalNode(node.left,handler)
		this.preOrderTraversalNode(node.right,handler)
	}
}
```

### 中序遍历 midOrderTraversal

1.中序遍历左子树
2.访问根节点
3.中序遍历右子树
```js
BinarySearchTree.prototype.midOrderTraversal = function(handler){
	this.midOrderTraversalNode(this.root,handler)
}
BinarySearchTree.prototype.midOrderTraversalNode = function(node,handler){
	if(node!==null){
		this.midOrderTraversalNode(node.left,handler)
		handler(node.key)
		this.midOrderTraversalNode(node.right,handler)
	}
}
```

### 后序遍历 postOrderTraversal

1.后序遍历左子树
2.后序遍历右子树
3.访问根节点
```js
BinarySearchTree.prototype.postOrderTraversal = function(handler){
	this.postOrderTraversalNode(this.root,handler)
}
BinarySearchTree.prototype.postOrderTraversalNode = function(node,handler){
	if(node!==null){
		this.postOrderTraversalNode(node.left,handler)
		this.postOrderTraversalNode(node.right,handler)
		handler(node.key)
	}
}
```

## 查找 最小值最大值

```js
BinarySearchTree.prototype.max = function() {
	let node = this.root;
	let max;
	while(node){
		max = node.key
		node = node.right
	}
	return max
}
```

```js
BinarySearchTree.prototype.min = function() {
	let node = this.root;
	let min;
	while(node){
		min = node.key
		node = node.left
	}
	return min
}
```

搜索某个值
```js
BinarySearchTree.prototype.search = function(key){
	let node = this.root;
	while(node){
		if(node.key > key){
			node = node.left
		}else if(node.key < key){
			node = node.right
		}else{
			return true
		}
	}
	return false
}
```

## 删除
比较复杂，先找到要删除的节点
有三种情况
1.叶节点
2.有一个子节点
3.有2个子节点

1.叶节点的情况：
将当前叶节点的parent的left或者right设置为null
2.一个子节点：
将当前节点的parent的left或right设置为不为null的子节点

```js
BinarySearchTree.prototype.delete = function(key){
	let node = this.root;
	let parent, isLeft;
	while(node.key !== node){
		parent = node;
		if(node.key > key){
			isLeft = true
			node = node.left
		}else if(node.key < key){
			parent = node;
			isLeft = false
			node = node.right
		}
		if(node === null) return false
	}
	if(node.left === null && node.right === null){
		if(node === this.root){//如果是根节点且只有一层
			this.root = null
		}else if(isLeft){
			parent.left = null
		}else{
			parent.right = null
		}
		
	}
	else if(node.left === null && node.right !== null){
		if(isLeft){
			parent.left = node.right
		}else{
			parent.right = node.right
		}
	}
	else if(node.left !== null && node.right === null){
		if(isLeft){
			parent.left = node.left
		}else{
			parent.right = node.left
		}
	}
	return true
}
```

3.两个子节点的情况
比较复杂

从下面的子节点里找到一个节点来替换当前节点。应该是current节点下所有节点中最接近current节点的，要么比current小一点叫前驱，要么比current大一点，叫后继。
比current小一点点的一定是左子树的最大值
比current大一点点的一定是右子树的最小值

```js
BinarySearchTree.prototype.delete = function(key){
	let node = this.root;
	let parent, isLeft;
	while(node.key !== node){
		parent = node;
		if(node.key > key){
			isLeft = true
			node = node.left
		}else if(node.key < key){
			parent = node;
			isLeft = false
			node = node.right
		}
		if(node === null) return false
	}
	if(node.left === null && node.right === null){
		if(node === this.root){//如果是根节点且只有一层
			this.root = null
		}else if(isLeft){
			parent.left = null
		}else{
			parent.right = null
		}
		
	}
	else if(node.left === null && node.right !== null){
		if(isLeft){
			parent.left = node.right
		}else{
			parent.right = node.right
		}
	}
	else if(node.left !== null && node.right === null){
		if(isLeft){
			parent.left = node.left
		}else{
			parent.right = node.left
		}
	}else{
		let successor = this.findSuccessor(node)
		if(node === this.root){
			this.root = successor
		}else if(isLeft){
			parent.left = successor
		}else{
			parent.right = successor
		}
		successor.left = node.left //将删掉节点的左子节点接在替换后的节点的左子节点
		
	}
	return true
}
//寻找后继节点（也就是比要删除的节点大一点点的节点，右子树的最大值）以及后继节点的父节点
Binary.prototype.findSuccessor(delNode){
	let current = delNode.right
	let successor = delNode;
	let successorParent = delNode
	while(current !== null){
		successorParent = successor
		successor = current
		current = current.left
	}
	if(successor !== delNode.right){//successo如果不直接是要删掉的右节点
		successorParent.left = successor.right //将successor的右子节点接在successorParent的左子结点上
		successor.right = delNode.right //将删除节点的右子树接在替换后节点的右节点上
	}
	return successor
}
```

找后继：
右子树的最小值，那么代表它肯定没有左子节点，将successor的parten的左子节点设置为successor右子节点即可

## 二叉树的缺陷

插入的有序数据的问题

初始化9 8 12的二叉树
插入 7、6、5、4、3的时候插入的数据会变成

				(9)
			   /      \
			(8)     (12)
            /
           (7)
           /  
        (6)
        /
	   (5)
	   /
	(4)

非平衡树
比较好的二叉搜索树应该是左右分开，
但连续插入数据后会分布不均匀
对平衡二叉树插入查找效率是O(logN)
非平衡就相当于编写了一个链表

尽量每个节点左边个数尽可能等于右边

常见的平衡树有AVL树和红黑树

## 平衡树
### AVL树
最早的平衡树，每个节点多存储了一个额外的信息。
效率不如红黑树

### 红黑树
通过一些特性保持平衡，现在平衡树应用基本都是红黑树