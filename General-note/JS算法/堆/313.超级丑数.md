---
title: 313.超级丑数
---
与264丑数相似，但这道题用最小堆要超时


**超级丑数** 是一个正整数，并满足其所有质因数都出现在质数数组 `primes` 中。

给你一个整数 `n` 和一个整数数组 `primes` ，返回第 `n` 个 **超级丑数** 。

题目数据保证第 `n` 个 **超级丑数** 在 **32-bit** 带符号整数范围内。

**示例 1：**

**输入：** n = 12, `primes` = `[2,7,13,19]`
**输出：** 32 
**解释：** 给定长度为 4 的质数数组`primes = [2,7,13,19]`，前 12 个超级丑数序列为：`[1,2,4,7,8,13,14,16,19,26,28,32]` 。

**示例 2：**

**输入：** `n = 1, primes = [2,3,5]`
**输出：** 1
**解释：** 1 不含质因数，因此它的所有质因数都在质数数组 `primes = [2,3,5]` 中。

用动态规划

后面的丑数一定是由前面的丑数与primes相乘得到的结果，第一个丑数一定是1

用三个数组dp、pointers、nums

dp：存放已入队丑数

pointers：存放当前primes数在dp里乘的数的指针，比如primes是`[2,3,5]`初始pointers是`[0,0,0]`表示当前所有prime与`dp[0]`相乘，得到`nums=[2,3,5]`，pointers为`[1,1,1]`。进入下一个循环，`dp=[1,2]`  `primes[0]`的指针就向后一位，`pointers=[2,1,1]`，`nums = [4,3,5]`。进入下一个循环，`dp = [1,2,3]` `primes[1]`指针向后一位，`pointers=[2,2,1]`，`nums = [4,6,5]`
dp = [1,2,3,4]; pointers = [3,2,1];  nums = [6,6,5]; （nums分别对应`dp[2]*primes[0], dp[1]*primes[1],dp[0]*primes[2]`)
dp = [1,2,3,4,5]; pointers = [3,2,2]; nums = [6,6,10];
dp = [1,2,3,4,5,6]; pointers = [4,3,2]; nums = [8,9,10];

nums：存放后续等待入队的丑数

```js
var nthSuperUglyNumber = function(n, primes) {

    const dp = new Array(n).fill(0);
    const pointers = new Array(primes.length).fill(0);
    const nums = new Array(primes.length).fill(1);
    for(let i = 0; i < n; i++){
        let min = Number.MAX_SAFE_INTEGER;
        for(let j = 0; j < primes.length; j++){
            min = Math.min(min, nums[j])
        }
        dp[i] = min
        for(let j = 0; j<primes.length; j++){
            if(nums[j] == min){
                nums[j] = dp[pointers[j]] * primes[j]
                pointers[j]++
            }
        }
    }
    return dp[dp.length-1]
};
```




















```js
var nthSuperUglyNumber = function (n, primes){
	const m = primes.length;
	const pointers = new Array(m).fill(0);
	const nums = new Array(m).fill(1);
	const dp = new Array(n).fill(0);
	for(let i = 0; i< n; i++){
		let min = Number.MAX_SAFE_INTEGER
		for(let j = 0; j < m; j++){
			min = Math.min(min, nums[j])
		}
		dp[i] = min
		for(let j = 0; j < m; j++){
			if(dp[i] === nums[j]){
				nums[j] = dp[pointers[j]] * primes[j]
				pointers[j]++
			}
		}
	}
	return dp[n-1]
}
```