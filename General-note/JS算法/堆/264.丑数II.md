---
title: 264.丑数II
---
给你一个整数 `n` ，请你找出并返回第 `n` 个 **丑数** 。

**丑数** 就是质因子只包含 `2`、`3` 和 `5` 的正整数。

**示例 1：**

**输入：** `n = 10`
**输出：** 12
**解释：** [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。

**示例 2：**

**输入：** `n = 1`
**输出：** 1
**解释：** 1 通常被视为丑数。

## 最小堆

最小堆的官方题解里面pop有一个需要注意的点，这个点卡了我很久
```js
    pop() {
        this.heap[0] = this.heap.pop();
        this.shiftDown(0);
        return this.heap[0];
    }
```
这个地方看似把堆顶覆盖了，而丢失了，实际上覆盖的是前一次的堆顶元素。
因为在heap为`[1]`的时候`this.heap[0] = this.heap.pop();`这行代码把pop出去的1又加回heap了
因此后一次heap为`[1,2,3,5]`在1被覆盖以后出来的是正确答案2

```js
class MinHeap {
	constructor(){
		this.heap = []	
	}
	
	getParentIdx(i){
		return (i-1) >> 1
	}
	
	getLeftIdx(i){
		return 2*i + 1
	}
	
	getRightIdx(i){
		return 2*i + 2
	}
	
	swap(i1,i2){
		let temp = this.heap[i1];
		this.heap[i1] = this.heap[i2];
		this.heap[i2] = temp
	}
	
	shiftUp(i){
		if(i === 0) {return;}
		let parentIdx = this.getParentIdx(i);
		if(this.heap[parentIdx] > this.heap[i]){
			this.swap(parentIdx,i);
			this.shiftUp(parentIdx)
		} 
	}
	
	shiftDown(i){
		const leftIdx = this.getLeftIdx(i);
		const rightIdx = this.getRightIdx(i);
		if(this.heap[i] > this.heap[leftIdx]){
			this.swap(leftIdx,i)
			this.shiftDown(leftIdx)
		}
		if(this.heap[i] > this.heap[rightIdx]){
			this.swap(rightIdx,i)
			this.shiftDown(rightIdx)
		}
	}

	insert(value){
		this.heap.push(value);
		this.shiftUp(this.heap.length - 1)
	}
	pop(){
		this.heap[0] = this.heap.pop();
		this.shiftDown(0);
		return this.heap[0];
		//这里有个很大的陷阱，在heap是[1]的时候，看似pop出去了，实际上还留在heap里，这就导致了后面的heap实际上是包含了再前一次的堆顶，因此要这样写。
	}
	peek(){
		return this.heap[0]
	}
	size(){
		return this.heap.length
	}
}

var nthUglyNumber = function(n){
	const factors = [2,3,5];
	const seen = new Set();
	const heap = new MinHeap();
	seen.add(1)
	heap.insert(1);
	let ugly = 0
	for(let i = 0; i< n; i++){
		ugly = heap.pop();
		for(const factor of factors){
			const next = ugly* factor
			if(!seen.has(next)){
				seen.add(next);
				heap.insert(next)
			}
		}
	}
	return ugly
}
```
## 动态规划

也可以用动态规划，参考313题

```js
var nthUglyNumber = function(n) {
    const dp = new Array(n).fill(0);
    dp[0] = 1;
    const primes = [2,3,5];
    const nums = [2,3,5];
    const pointers = [1,1,1];
    for(let i = 1; i< n; i++){
        dp[i] = Math.min(Math.min(nums[0],nums[1]),nums[2])
        for(let j = 0; j < 3; j++){
            if(nums[j] == dp[i]){
                nums[j] = dp[pointers[j]] * primes[j]
                pointers[j]++
            }
        }
    }
    return dp[n-1]
};
```