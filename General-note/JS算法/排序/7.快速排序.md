---
title: 7.快速排序
---
快速排序几乎是最快的，是比较好的选择

希尔排序是插入排序的升级版
快速排序是冒泡排序的升级版

快速排序在一次循环中，找出某元素的正确位置，之后不需要移动

快速排序思想：递归分而治之

1.选出一个数字
2.将所有小于这个数的放左边，大于的放右边

操作：
选一个数pivot，跟最后一个数交换。
左右指针初始化0和length-2
左指针的数小于pivot右移一位，大于就先不动
右指针的数大于pivot左移一位，小于的时候不动，并将左右指针的数进行交换。
直到左右指针相等
交换左右指针指向的数和pivot

再对左右子数组进行同样操作。

选择枢纽pivot重要，要选一个合适的枢纽
第一种是选第一个元素，但不能保证效率。
第二种方案用随机数
第三种方案：取头、中、尾三个数的中位数
```js
function quickSort(arr){
	quick(arr,0,arr.length-1)
	return arr
}

//找头、尾、中部的中位数，传入参数为指针,并将中位数放在right-1的位置
//10,...,20,...,30变为10,......,20,30
function median(arr,left,right){
	let mid = Math.floor((left+right)/2)
	if(arr[left] > arr[mid]){
		swap(arr,left,mid)	
	}
	if(arr[mid] > arr[right]){
		swap(arr,mid,right)
	}
	if(arr[left] > arr[mid]){
		swap(arr,left,mid)
	}
	swap(arr,mid,right-1)
	return arr[right-1]
}

//在数组里交换两个数
function swap(arr,i1,i2){
	let temp = arr[i1]
	arr[i1] = arr[i2]
	arr[i2] = temp
}

//快排递归
function quick(arr,left,right){
	if(left >= right) return
	let pivot = median(arr,left,right)
	let l = left+1
	let r = right-2
	while(true){
		while(arr[l] < pivot){l++}
		while(arr[r] > pivot){r--}
		if(l < r){
			swap(arr,l,r)
		}else{
			break
		}
	}
	swap(arr, l, right-1)
	quick(arr,left,l-1)
	quick(arr,l+1,right)
}
```