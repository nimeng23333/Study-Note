---
title: 6.希尔排序
---
插入排序的高效改进版

插入排序的问题：假设有个很小的数据在右端，那么就会有很多数据项往右移。如果有某种方法不需要一个个移动中间的数据项，就能优化效率

希尔排序思路：
先分组，再排序
但这个分组不是直接三个一组三个一组这种
81、94、645、31、5、97、315、95、64、1
不是（81、94、645）、（31、5、97）、（315、95、64）、（1）
本来1应该是第一个，结果分组问题导致它一直在最后

希尔排序的分组：
先以间隔5进行分组排序，再以间隔3进行排序，再以间隔1进行排序。
间隔5就是第1个数和1往后数第五个数，也就是6一组，第2个数和第7个数一组
81、94、645、31、5、97、315、95、64、1
1       2      3       4     5    1      2       3      4     5
间隔5分组并排序：（81、97）、（94、315）、（95、645）、（31、64）（1、5）
81、94、95、31、1、97、315、645、64、5
1       2     3      1     2    3      1         2      3     1
间隔3分组并排序：（81、31、315、5）、（94、1、645）、（95、97、64）
5、1、64、31、94、95、81、645、97、315
间隔1并排序（也就是不分组）


因此希尔排序又叫增量递减算法

合适的增量：
原稿建议初始间距是n/2，依次减半
n=100，间隔为50、25、12、6、3、1

Hibbard增量：
增量算法为2^k -1 也就是1 3 5 7

Sedgewick增量
{1,5,19,41,109, ...} 每一项都是`9*4^i - 9*2^i +1`或`4^i - 3*2^i + 1

```js
function shellSort(arr){
	let length = arr.length
	let gap = Math.floor(length / 2)
	while(gap >=1){
		for(let i = gap; i< length; i++){
			let temp = arr[i]
			let j = i
			while(arr[j-gap] > temp && j - gap > 0){
				arr[j] = arr[j-gap]
				j -= gap
			}
			arr[j] = temp
		}
		gap = Math.floor(gap / 2)
	}
}
```