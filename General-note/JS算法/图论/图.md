---
title: 图
---
图结构

与树有点相似
图论是数学一个分支，在数学上树是图的一种

研究顶点和边组成的图形的数学理论和方法
目的是事物之间的关系，顶点代表事物，边代表两个事物之间的关系

树可以模拟公司组织架构等

图的现实案例：地铁图、人际关系网、铁路网

顶点vertex之间的关系不能用树来模拟，可以用图来模拟

## 图的特点
一组顶点 V
一组边 E
边可以有方向也可以有方向

## 图的术语
顶点
边
度：一个顶点相邻顶点的数量
路径：顶点的连续序列
简单路径：不包含重复顶点
回路：第一个顶点和最后一个顶点相同的路径
无向图：所有边都没有方向
有向图：图中的边有方向
无权图：边没有携带权重，不能说哪个边更远或更长
带权图：边有一定权重，可以是距离或者时间或者票价

## 图的表示方式

1.邻接矩阵

让每个节点和一个整数关联，该整数为数组下标值，我们用一个二维数组来表示顶点之间的连接
    A   B   C  D   E   F   G   H  I
A      0   1   1   1   0   0   0   0   0
B      1   0   0   0   1   1   0   0   0
C      1   0   0   1   0   0   1   0   0
D      1   0   1   0   0   0   1   1   0
E       0   1   0   0   0   0   0   0   1
F       0   1   0   0   0   0   0   0   0
G      0   0   1   1   0   0   0   0   0
H      0   0   0   1   0   0   0   0   0
I        0   0   0   0   1   0   0   0   0

`[0][2]`表示 a c之间是否有边

2.邻接表
由每个顶点及顶点相邻的顶点列表
可以用数组、链表、哈希表存储
A: BCD
B: AEF
C: ADG
D: ACGH

计算“出度”很方便，计算“入度”很麻烦
出度事指向别人的数量
入度需要一个逆邻接表

## 创建图类
Graph
```js
	function Graph(){
		this.vertexes = [];
		this.edges = new Map();
	
		Graph.prototype.addVertex = function(v){
			this.vertexes.push(v)
			this.edges.set(v,[])
		}
		Graph.prototype.addEdges = function(v1,v2){
			this.edges.get(v1).push(v2)
			this.edges.get(v2).push(v1)
		}
		Graph.prototype.toString = function(){
			let result = "";
			for(let i = 0; i< this.vertexes.length; i++){
				result += this.vertexes[i] + '->'
				let edges = this.edges.get(this.vertexes[i])
				for(let j = 0; j< edges.length; j++){
					result += edges[j]
				}
				result += "\n"//换行
			}
			return result
		}
	}
```

## 图的遍历
图的遍历思想和树的遍历时一样的
意味着每个顶点访问一变，而且没有重复访问，跟toString就不一样

两种遍历
广度优先搜索 Breadth-First Search BFS
深度优先搜索 Depth-First Search DFS
两种遍历都要明确第一个访问的顶点

BFS 基于队列，入队列的先被探索
DFS基于栈或递归，将顶点存入栈，顶点沿着路径被探索

为了记录是否被访问，用三种颜色
白色：没被访问
灰色：被访问但没探索
黑色：访问且探索
```js
Graph.prototype.initializeColor = function(){
	const colors = {}
	for(let i = 0; i< this.vertexes.length; i++){
		colors[this.vertex[i]] = "white"
	}
	return colors;
}
```

创建一个队列Q
将v标注为被发现的灰色，并将v加入队列，
如果Q非空，执行程序
将v从Q取出
将v标注为灰色
将v所有未访问过的加入队列
将v标志为黑色

```js
Graph.prototype.bfs = function(v){
	const colors = this.initializeColor()
	const queue = [];
	queue.push(v);
	while(queue.length > 0){
		colors[queue[0]] = "gray";
		let edges = this.edges.get(queue[0])
		for(let i = 0; i< edges.length; i++){
			if(colors[edges[i]] === "white"){
				queue.push(edges[i])
				colors[edges[i]] === "gray"
			}
		}
		colors[queue[0]] = "black"
		queue.splice(0,1)
	}
}
```

深度优先搜索 DFS
用递归访问
```js
Graph.prototype.dfs = function(v,handler){
	const colors = this.initializeColor();
	this.dfsVisit(v,colors,handler)
}
Graph.prototype.dfsVisit = function(v, colors,handler){
	colors[v] = "gray"
	handler(v)
	const edges = this.edges.get(v)
	for(let i = 0; i< edges.length;i++){
		let e = list[i]
		if(colors[e] === "white"){
			this.dfsVisit(e,colors,handler)
		}
	}
	colors[v] = "black"
}
```
