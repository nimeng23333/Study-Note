---
title: 二分法
---

通常时间为O(logN)

[二分查找 红蓝染色法【基础算法精讲 04】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1AP41137w7/?vd_source=a87b76f83c1435a532174e2c811d8573)

两边闭区间

```
L = 0
R = n-1
while left <=right 
left = mid+1
right = mid-1
return left
```

【6，7，8，8，9】
	 R    L

R可以走到-1，L可以走到n

左闭右开

```
L = 0
R = n
while left < right
left = mid + 1
right = mid
return left/right
```

【6，7，8，8，9】
        RL

开区间
```
L = -1
R = n
while left < right-1
left = mid
right = mid
return right
```

【6，7，8，8，9】
     L    R

空间复杂度是O(1)


考虑二分的时候如果遇到两个数组，可以分别考虑两个数组哪个更适合作为二分的工具。
比如2080题
[2080. 区间内查询数字的频率 - 力扣（LeetCode）](https://leetcode.cn/problems/range-frequency-queries/)

请你设计一个数据结构，它能求出给定子数组内一个给定值的 **频率** 。

子数组中一个值的 **频率** 指的是这个子数组中这个值的出现次数。

请你实现 `RangeFreqQuery` 类：

- `RangeFreqQuery(int[] arr)` 用下标从 **0** 开始的整数数组 `arr` 构造一个类的实例。
- `int query(int left, int right, int value)` 返回子数组 `arr[left...right]` 中 `value` 的 **频率** 。

一个 **子数组** 指的是数组中一段连续的元素。`arr[left...right]` 指的是 `nums` 中包含下标 `left` 和 `right` **在内** 的中间一段连续元素。

**示例 1：**

**输入：**
```js
["RangeFreqQuery", "query", "query"]
[[[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]], [1, 2, 4], [0, 11, 33]]
```
**输出：**
```js
[null, 1, 2]
```

**解释：**
```js
RangeFreqQuery rangeFreqQuery = new RangeFreqQuery([12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]);
rangeFreqQuery.query(1, 2, 4); // 返回 1 。4 在子数组 [33, 4] 中出现 1 次。
rangeFreqQuery.query(0, 11, 33); // 返回 2 。33 在整个子数组中出现 2 次。
```

这道题不超时的技巧在于先将原始数组arr里的每个数所在的下标记录为一个数组，这样在查询的时候可以避免重复计算

```js
var RangeFreqQuery = function(arr) {
    this.arr = arr
    this.position = {}
    for(let i = 0; i< arr.length;i++){
        if(this.position[arr[i]]){
            this.position[arr[i]].push(i)
        }else{
            this.position[arr[i]] = [i]
        }
    }
};


RangeFreqQuery.prototype.query = function(left, right, value) {
    const idx = this.position[value]
    if(!idx) return 0
    let p = binaryCheck(idx,left,true)
    let q = binaryCheck(idx,right,false)
    return q-p
    function binaryCheck(arr,target,lower){
        if(arr[arr.length-1] < target || (!lower && arr[arr.length-1] === target)) return arr.length
        let left = 0,right = arr.length-1
        while(left < right){
            let mid = (left + right) >> 1
            if((lower && arr[mid] >= target) || !lower && arr[mid] > target){
               right = mid
            }else{
                left = mid + 1
            }
        }
        return  right
    }
```

二分查找思路：
找到存储的下标数组 第一个`>=left`的值，记为p，没有找到就为`arr.length`
找到存储的下标数组 第一个 `> right`的值，记为q，没有就为`arr.length`
答案是q-p

比如下标数组idx为`[1,4,5]`
left为4，right为10
p为1，q为3
答案为2