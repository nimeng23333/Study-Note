---
title: 63.不同路径 II
---
给定一个 `m x n` 的整数数组 `grid`。一个机器人初始位于 **左上角**（即 `grid[0][0]`）。机器人尝试移动到 **右下角**（即 `grid[m - 1][n - 1]`）。机器人每次只能向下或者向右移动一步。

网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。机器人的移动路径中不能包含 **任何** 有障碍物的方格。

返回机器人能够到达右下角的不同路径数量。

测试用例保证答案小于等于 `2 * 109`。

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg)

**输入：** `obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]`
**输出：** 2
**解释：** 3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 `2` 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右

## 动态规划

每一个格子的可达路径数：有障碍的时候为0
没有障碍的时候为 上一个格子的【可达路径数】+左一个格子的【可达路径数】
第一个格子`f[0][0]`有障碍的时候为0，没有为1
比如示例的路径数矩阵：
1  1  1
1  0  1
1  1  2

```js
var uniquePathsWithObstacles = function(obstacleGrid) {
    let n = obstacleGrid.length;
    let m = obstacleGrid[0].length;
    const f = new Array(n).fill(new Array(m).fill(0));
    f[0][0] = obstacleGrid[0][0] === 1? 0 : 1;
    for(let i = 0; i< n; i++){
        for(let j = 0; j < m; j++){
            if(obstacleGrid[i][j] === 1){
                f[i][j] = 0
                continue
            }

            if(i === 0 && j > 0){
                f[i][j] = f[i][j-1]
            }
            if(j === 0 && i > 0){
                f[i][j] = f[i-1][j]
            }
            if(i > 0 && j > 0){
                f[i][j] = f[i][j-1] + f[i-1][j]
            }
        }
    }
    return f[n-1][m-1]
};
```

这里空间复杂度为O(nm)可以通过【滚动数组】的思想来优化空间复杂度

滚动数组是一种在动态规划中常用的优化技巧，它的核心思想是通过覆盖不再需要的状态来节省空间，从而降低空间复杂度。在某些情况下，滚动数组甚至可以降低时间复杂度。这种方法特别适用于那些只需要最终结果而不需要保留所有中间状态的问题。

以斐波那契数列为例，我们知道每个数只与前两个数有关，因此不需要保留整个数列，只需保留最近的两个数即可。

