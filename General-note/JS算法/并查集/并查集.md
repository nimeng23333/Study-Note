---
title: 并查集
---
通用模板
```js
class UnionFind {
	constructor(n){
	    this.fa = []; // 代表元
	    this.size = []; // 集合大小
	    this.count = n; // 连通块个数
	    // 一开始有 n 个集合 {0}, {1}, ..., {n-1}
        // 集合 i 的代表元是自己，大小为 1
        for (int i = 0; i < n; i++) {
            this.fa.push(i);
            this.size.push(1)
        }
        this.cc = n;
	}

    // 返回 x 所在集合的代表元
    // 同时做路径压缩，也就是把 x 所在集合中的所有元素的 fa 都改成代表元
    find(x) {
        // 如果 fa[x] == x，则表示 x 是代表元
        if (this.fa[x] != x) {
            this.fa[x] = find(this.fa[x]); // fa 改成代表元
        }
        return this.fa[x];
    }

    // 判断 x 和 y 是否在同一个集合
    isSame(x, y) {
        // 如果 x 的代表元和 y 的代表元相同，那么 x 和 y 就在同一个集合
        // 这就是代表元的作用：用来快速判断两个元素是否在同一个集合
        return this.find(x) === this.find(y);
    }

    // 把 from 所在集合合并到 to 所在集合中
    // 返回是否合并成功
    merge(from, to) {
        const rootX = this.find(from);
        const rootY = this.find(to);
        if (rootX === rootY) { // from 和 to 在同一个集合，不做合并
            return false;
        }
        this.fa[rootX] = rootY; // 合并集合。修改后就可以认为 from 和 to 在同一个集合了
        this.size[rootY] += this.size[rootX]; // 更新集合大小（注意集合大小保存在代表元上）
        // 无需更新 size[x]，因为我们不用 size[x] 而是用 size[find(x)] 获取集合大小，但 find(x) == y，我们不会再访问 size[x]
        this.count--; // 成功合并，连通块个数减一
        return true;
    }

    // 返回 x 所在集合的大小
    getSize(x) {
        return this.size[this.find(x)]; // 集合大小保存在代表元上
    }
}
```