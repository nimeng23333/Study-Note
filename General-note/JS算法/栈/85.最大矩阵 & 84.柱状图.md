---
title: 85.最大矩阵 & 84.柱状图
---
85题 困难

给定一个由 `0` 和 `1` 组成的矩阵 `matrix` ，找出只包含 `1` 的最大矩形，并返回其面积。

**注意：** 此题 `matrix` 输入格式为一维 `01` 字符串数组。

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg)

**输入：** matrix = ["10100","10111","11111","10010"]
**输出：** 6
**解释：** 最大矩形如上图所示。

暴力解法：对每一个matrix上的元素都记录其左边的连续1的个数，形成一个新的矩阵left
比如：第i行为1,0,1,1,1，left里的第i行为1,0,1,2,3

将left里的每一个元素作为矩形的最右下角的元素，向上查询
比如某一列为5,0,2,1,2,4,3，对最后一个元素，向上查询width和area
w = 3, a = 3 * 1;
w = 3, a = 3 * 2;
w = 2, a = 2 * 3;
w = 1, a = 1 * 4;
w = 1, a = 1 * 5;
w = 0, a = 0 * 6;
w = 0, a = 0 * 7;
最大的为6

```js
var maximalRectangle = function(matrix) {
    const m = matrix.length;
    if(m === 0){
        return 0
    }
    const n = matrix[0].length;
    const left = new Array(m).fill(0).map(() => new Array(n).fill(0));

    for(let i = 0; i < m; i++){
        for(let j = 0; j < n; j++){
            if(matrix[i][j] == 1){
                left[i][j] = j === 0 ? 1 : left[i][j-1] + 1
            }
        }
    }

    let res = 0;
    for(let i = 0; i < m; i++){
        for(let j = 0; j < n; j++){
            let width = left[i][j];
            let area = width;
            if(res < area){
                res = area
            }

            if(i > 0){
                for(let k = i-1; k > -1; k--){
                    width = Math.min(width, left[k][j]);
                    area = width * (i-k+1);
                    if(res < area){
                        res = area
                    }
                }
            }
        }
    }
    return res;
};
```

# 单调栈

与84.柱状图中最大矩形单调栈做法类似，形成left以后用柱状图的单调栈方法

题目：
给定 _n_ 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

**示例 1:**

![](https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg)

**输入：** `heights = [2,1,5,6,2,3]`
**输出：** 10
**解释：** 最大的矩形为图中红色区域，面积为 10

维护一个单调递增栈，当新的bar到来的时候如果比栈顶高，就入栈，比栈顶矮，就将栈顶pop出来，并操作。

### 为什么是单调递增？为什么是栈？
如果是单调递减栈
新 bar 比栈顶矮，入栈，维持递减性
新 bar 比栈顶高，靠近栈顶的矮个阵营会补强，继续考察，排后面的高个停止生长，需要抛弃
可是高个阵营不在栈顶，不好出栈啊
### 那，队列可以吗？让高个从队尾出列？
好的，但是，人家新 bar 要进来啊，要从高个出列的地方入列，才能保持单调性，这就不是队列了，是栈了
所以，只能是单调递增栈
新 bar 比栈顶高，入栈，保持单增性
新 bar 比栈顶低，栈顶的高个阵营停止生长，出栈，后头的矮个阵营留待观察


当前栈内高的栈顶遇到了更矮的bar，将停止发育，计算了长方形面积以后就出栈了，当当前栈顶不再高于当前bar的时候就让当前bar入栈

栈记录的是当前heights的索引
```js
var largestRectangleArea = function(heights) {

    let maxArea = 0;
    heights = [0, ...heights, 0];
    const stack = [];
    for(let i = 0; i< heights.length; i++){
        while(heights[i] < heights[stack[stack.length - 1]]){
            let stackTopIndex = stack.pop();
            maxArea = Math.max(maxArea, heights[stackTopIndex] * (i - stack[stack.length - 1] - 1))
        }
        stack.push(i)
    }
    return maxArea
};
```
前后两个0是为了让第一个入栈，最后一个出栈