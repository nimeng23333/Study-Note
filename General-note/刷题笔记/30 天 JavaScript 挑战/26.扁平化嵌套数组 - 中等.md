---
title: 26.扁平化嵌套数组 - 中等
---
请你编写一个函数，它接收一个 **多维数组** `arr` 和它的深度 `n` ，并返回该数组的 **扁平化** 后的结果。

**多维数组** 是一种包含整数或其他 **多维数组** 的递归数据结构。

数组 **扁平化** 是对数组的一种操作，定义是将原数组部分或全部子数组删除，并替换为该子数组中的实际元素。只有当嵌套的数组深度大于 `n` 时，才应该执行扁平化操作。第一层数组中元素的深度被认为是 0。

请在没有使用内置方法 `Array.flat` 的前提下解决这个问题。

**示例 1：**

**输入**
`arr = [1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]`
`n = 0`
**输出**
`[1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]`

**解释**
传递深度 n=0 的多维数组将始终得到原始数组。这是因为 子数组(0) 的最小可能的深度不小于 n=0 。因此，任何子数组都不应该被平面化。

**示例 2：**

**输入**
`arr = [1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]`
`n = 1`
**输出**
`[1, 2, 3, 4, 5, 6, 7, 8, [9, 10, 11], 12, 13, 14, 15]`

**解释**
以 4 、7 和 13 开头的子数组都被扁平化了，这是因为它们的深度为 0 ， 而 0 小于 1 。然而 `[9,10,11]` 其深度为 1 ，所以未被扁平化。

**示例 3：**

**输入**
`arr = [[1, 2, 3], [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]`
`n = 2`
**输出**
`[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]`

**解释**
所有子数组的最大深度都为 1 。因此，它们都被扁平化了。

方法1：递归
```js
var flat = function(arr, n){
	const res = [];

	const flatten = (nums, level) =>{
		for(let num of nums){
			if(Array.isArray(num) && level > 0){
				flatten(num, level - 1)
			}else{
				res.push(num)
			}
		}
	}

	flatten(arr,n)
	return res
}
```

方法2：迭代队列
```js
var flat = function(arr, n){
	let nestedArray = true;
	let queue;
	let depth = 0;

	while(nestedArray === true && depth < n){
		nestedArray = false;
		queue = [];
		for(let i = 0; i< arr.length; i++){ //for循环i++一定是在最后。for (初始化; 条件; 迭代)
			if(Array.isArray(arr[i])){
				nestedArray = true;
				queue.push(...arr[i])
			}else{
				queue.push(arr[i])
			}
		}
		arr = [...queue];
		depth++;
	}

	return arr
}
```

`for` 循环包含三个主要部分：初始化、条件和迭代。

### 详细解释每一步

1. **初始化**：`let i = 0`
    
    - 这一步在循环开始前执行一次，用于初始化循环控制变量。在这个例子中，`i` 被初始化为 `0`。
2. **条件**：`i < arr.length`
    
    - 在每次循环迭代开始时都会检查这个条件。如果条件为 `true`，则执行循环体；如果为 `false`，则终止循环。在这个例子中，条件是 `i` 小于数组的长度 `arr.length`。
3. **迭代**：`i++`
    
    - 这一步在每次循环体执行完后执行，用于更新循环控制变量。在这个例子中，`i++` 表示 `i` 自增 `1`。

方法3：迭代堆栈

```js
var flat = function(arr, n){
	const stack = [...arr.map((item) => [item,n])];
	const res = []
	while(stack.length > 0){
		const topItem = stack.pop();
		if(Array.isArray(topItem[0]) && n > 0){
			for(let item of topItem[0]){
				stack.push([item, topItem[1] - 1])
			}

		}else{
			res.push(topItem[0])
		}
	}
	res.reverse();
	return res
}
```

#### 面试提示
1. 解释扁平化多维数组的概念。为什么在某些情景下扁平化很有用？
扁平化多维数组意味着通过删除任何嵌套数组并替换为它们的实际元素将其转换为单维数组。这在需要将数组作为扁平列表进行处理、而不考虑其原始嵌套结构时很有用。它简化了搜索、过滤或转换数组元素的操作。

2. 是否存在需要考虑的特殊情况或边缘情景？你的解决方案如何处理这些情况？
是的，我们应该考虑空数组或没有嵌套数组的情况。在这种情况下，函数应该返回原始数组，因为没有需要扁平化的嵌套数组。此外，我们需要处理深度 n 为负数或超出数组的实际深度的情况。在这些情况下，函数也应返回原始数组，而不进行扁平化。

3. 你的解决方案如何处理输入数组中的循环引用或自引用数组？
循环引用或自引用数组可能导致无限递归。提供的解决方案不显式处理循环引用。如果输入数组包含循环引用，递归扁平化过程可能导致无限循环或堆栈溢出错误。