---
title: 14.执行可取消的延迟函数 - 简单
---
给定一个函数 `fn` ，一个参数数组 `args` 和一个以毫秒为单位的超时时间 `t` ，返回一个取消函数 `cancelFn` 。

在 `cancelTimeMs` 的延迟后，返回的取消函数 `cancelFn` 将被调用。

setTimeout(cancelFn, cancelTimeMs)

最初，函数 `fn` 的执行应该延迟 `t` 毫秒。

如果在 `t` 毫秒的延迟之前调用了函数 `cancelFn`，它应该取消 `fn` 的延迟执行。否则，如果在指定的延迟 `t` 内没有调用 `cancelFn`，则应执行 `fn`，并使用提供的 `args` 作为参数。

**示例 1:**

**输入：** `fn = (x) => x * 5, args = [2], t = 20`
**输出：** `[{"time": 20, "returned": 10}]`
**解释：**
```js
const cancelTimeMs = 50;
const cancelFn = cancellable((x) => x * 5, [2], 20);
setTimeout(cancelFn, cancelTimeMs);
```

取消操作被安排在延迟了 cancelTimeMs（50毫秒）后进行，这发生在 fn(2) 在20毫秒时执行之后。

答案：
```js
	var cancellable = function(fn,args,t){
		const timer = setTimeout(()=>{
			fn(...args)
		},t)
		return function(){
			clearTimeout(timer)
		}
	}
```

```js
var cancellable = function(fn, args, t) {
    let call = false;
    setTimeout(()=>{
        if(!call){
            fn(...args)
        }
    },t)
    return function(){
        call = true
    }
};
```

### 闭包
在 JavaScript 中，闭包是函数和函数被声明时的词法环境的组合。词法环境包括在闭包创建时可用的变量、函数和作用域。

工作原理：

当一个函数定义在另一个函数内部时，就创建了一个闭包。内部函数保留对外部函数的变量和作用域的引用。
当外部函数执行完成并返回时，闭包仍然保持其捕获的变量和作用域链的引用。
闭包允许内部函数访问和操作其外部函数的变量，即使外部函数的执行已经完成。
这种行为是可能的，因为闭包保持对其外部函数的变量和作用域链的引用，防止它们被垃圾回收。

在问题的上下文中，闭包被用于保持对定时器变量的引用，即使创建闭包的函数已经返回。这使得取消函数能够访问并修改定时器变量，有效地取消了延迟函数的执行。

### 面试提示
1. 你能解释在 setTimeout 回调中使用的 apply 方法的作用吗？

apply 方法用于使用提供的 args 数组作为参数调用延迟执行的函数 fn。它允许我们将 args 数组中的参数动态传递给 fn，以确保在最终执行 fn 时传递正确的参数。此外，使用 null 作为第一个参数的 apply 允许我们在不指定特定上下文（this 值）的情况下调用函数。由于延迟执行的函数不依赖于特定的上下文，因此使用 null 是合适的。

2. 如何处理延迟函数需要特定上下文（this 值）的执行情况？

在延迟函数依赖特定上下文（this 值）的情况下，可以使用 bind 方法将所需的上下文绑定到 fn。这会创建一个具有指定上下文的新函数，然后您可以将绑定的函数传递给 setTimeout 以进行延迟执行。

3. 是否可以修改实现以支持在执行过程中动态更改延迟？

是的，可以改进可取消函数的实现以支持动态更改延迟。您可以修改实现以存储计时器ID，并在设置新延迟之前使用 clearTimeout 来清除计时器。这样，您可以动态更改延迟。

4. 有哪些适用于带延迟的可取消函数的潜在用例？

具有延迟的可取消函数在需要在一定延迟后执行某个操作的情况下非常有用，但在可能需要在执行前取消该操作的情况下。例如，在用户界面中的场景中，用户执行某个动作后，可能需要在一定延迟后显示通知。但是，如果用户执行了使通知无关紧要的不同动作，可以取消通知的计划显示。

另一个场景可能是在游戏环境中，需要在延迟后执行某个动作，但是中间的用户动作或游戏事件可能需要取消计划的动作。需要注意的是，这些用例与防抖或节流的情况不同，后者旨在控制函数调用的速率，而不是安排和取消可能的操作。

5. 使用 setTimeout 来安排延迟执行的函数的执行的潜在缺点或限制是什么？

一个限制是 setTimeout 不是精确的，可能受到系统负载等其他因素的影响。如果需要精确的定时，一些情况下会使用替代方法，如 Web Workers 或 Web 动画 API，但它们用途不同，不能总是直接替代 setTimeout。

使用 performance.now() 方法可以实现更精确的时间控制，它提供了子毫秒分辨率的时间戳测量，但仍然不能保证函数会在指定的延迟后运行，因为 JavaScript 是单线程的。

6. 是否可以修改可取消函数以支持在执行过程中可以动态更改的延迟？

是的，可以增强可取消功能以支持延迟的动态变化。您可以修改实现以存储超时 ID，并在使用更新的延迟设置新的超时之前使用 clearTimeout。

7. 你能解释一下“防抖”的概念吗？它与可取消的延迟功能有何关系？

防抖是一种编程实践，用于确保耗时的任务不会如此频繁地触发，这在处理用户输入事件等可能频繁而快速触发事件的情况下尤其有用。防抖的核心概念是在执行函数之前设置延迟，然后在延迟到期之前每次请求函数时重置该延迟。

虽然带有延迟的可取消函数与防抖有相似之处，因为两者都涉及可以取消的延迟函数执行，但它们并没有内在联系。可取消函数更适合动作或计算在执行前就被废弃的情况。另一方面，防抖通常不涉及显式创建可取消函数；相反，它直接在函数内清除并重置计时器。