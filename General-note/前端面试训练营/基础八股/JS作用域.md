---
title: JS作用域
---
# 概念

JS作用域就是在程序中定义变量的可见范围



**块级作用域**是指由一对花括号` {}` 包裹的代码块中定义的变量，这些变量在代码块外部是不可见的。这是一个在ES6中引入的概念，旨在提供比传统的函数作用域更细粒度的变量控制方式。在块级作用域中，可以使用_let_和_const_关键字声明变量，这些变量的作用域被限制在声明它们的块中。

示例代码

```js
function fn1(x) {

var a = 0;

let b = 0;

{

var c = 1; // 未使用let或const，c没有块级作用域，属于fn1的函数作用域

let d = 1; // d具有块级作用域，只能在当前代码块中访问

}

// 在这里，变量c是可访问的，但变量d不是

}
```

在上述代码中，变量_c_使用_var_声明，因此它没有块级作用域，而是属于函数_fn1_的作用域。相反，变量_d_使用_let_声明，因此它具有块级作用域，只能在它被声明的那个块内访问。

循环中的块级作用域

在循环中使用_let_声明的变量也会具有块级作用域。例如，在_for_循环中，每次迭代都会为计数器创建一个新的作用域。

```js
for (let i = 0; i < 5; i++) {

// 在这里，i具有块级作用域

}

// 在这里，i不再可访问
```

在这个例子中，每次循环迭代时，变量_i_都是在一个新的块级作用域中声明的，因此在循环外部它是不可访问的。

块级作用域与闭包

块级作用域对于理解闭包也非常重要。闭包允许函数访问并操作函数外部的变量。在块级作用域中声明的变量，如果被一个内部函数引用，那么这个内部函数就形成了一个闭包。

```js
function outer() {

let outerVar = 'I am from outer';

{

let innerVar = 'I am from inner';

function innerFunc() {

console.log(outerVar); // 访问外部变量，形成闭包

console.log(innerVar); // 访问内部变量

}

innerFunc();

}

// 在这里，innerVar不可访问，但outerVar仍然可访问

}
```

在这个例子中，_innerFunc_函数形成了一个闭包，因为它访问了外部函数_outer_中的变量_outerVar_，以及它自己块级作用域中的变量_innerVar_。

总结

块级作用域是一个强大的特性，它提供了更细粒度的控制变量可见性的能力。通过使用_let_和_const_，开发者可以确保变量只在需要的地方可见，从而减少错误和提高代码的可维护性。在ES6及以后的版本中，块级作用域已成为JavaScript中管理变量的首选方式。

# 总结
在 JavaScript 中，变量的作用域是由它们在代码中声明的位置所决定的。当程序执行时，JavaScript 引擎会根据变量声明的位置来确定变量的作用域。通常，let和const变量在声明的位置下方的代码都可以访问该变量，而在声明位置上方的代码则无法访问该变量。

# 作用域链

**作用域链**是JavaScript中一个重要的概念，它决定了变量的查找顺序。当在JavaScript中使用一个变量时，JavaScript引擎会首先在当前作用域下寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域

如果没使用let、 var、const关键词声明变量，变量会直接成为全局变量。
比如
```js
function test(){
	x = 10
}
console.log(x) //10
```

这里x=10并不会因为没有关键词而报错，但如果在严格模式（`"use strict";`）下会报错

## JavaScript 暂时性死区
在 JavaScript 中，暂时性死区（Temporal Dead Zone，简称 TDZ）是指在使用 let 和 const 声明的变量之前，这些变量在其作用域内是不可访问的。如果尝试在声明之前访问这些变量，会抛出 ReferenceError 错误。