---
title: ==与===的区别
---
`==`与`===`都是判断是否相等，但他们的区别在于
`==`比较的时候会进行类型转换，大概如下
1.类型相同直接比较
2.当比较字符与数值的时候，会将字符串转为数字比较。比如“1” 与 1 相等。
3.当比较布尔值与数值的时候，会将布尔值转化为数字。比如false与0相等。
4.undefined与null相等。（undefined和null与0、false不相等）
5.一个是对象，另一个是数字、布尔值或字符串的时候，会将对象转化为原始值进行比较。
而`===`比较不会进行类型转换。建议优先使用 === 运算符进行比较，因为它可以避免类型转换的问题，更加严格和安全

在`==`的对象比较时额外注意：

`{} == {}`是fasle。两个对象转换后的原始值也还是对象

`{} == {}` **对象比较的是引用**：`==` 操作符在比较对象时，比较的是它们在内存中的引用，而不是内容。即使两个对象的内容相同，只要它们不是同一个对象，`==` 就会返回 `false`。`{}` 每次都会创建一个新的对象，因此它们的引用不同。

 **`{1:1} == 1` 返回 `false`**：
- `{1:1}` 是一个对象，而 `1` 是一个数字。
- 对象和数字比较时，对象会先通过 `valueOf()` 或 `toString()` 转换为原始值，再进行比较。
- `{1:1}` 转换为原始值后是 `"[object Object]"`，与 `1` 不同，因此返回 `false`。

**`{1:1} == "[object Object]"`返回`true`**


总结：默认情况下，对象在比较时不会自动转换为原始值，除非你显式地重写 `valueOf()` 或 `toString()` 方法。
```js
let obj = {
  obj: 1,
  valueOf: function() {
    return 1;
  }
};

console.log(obj == 1); // true
```

```js
// 对象转字符串后与字符串比较
console.log({} == "[object Object]"); // true

// 对象转数字（先转字符串，再转数字为NaN）
console.log({} == 0); // false（NaN != 0）
```

```js
console.log([5] == [5]) //false，因为类型相同，比较引用地址
console.log("5,5" == [5,5]) //true，类型不同，array转换为原始值
console.log({} == {}) //false，因为类型相同，比较引用地址
console.log({} == "[object Object]") //true，类型不同，object转换为原始值（.toString())
```