---
title: JS事件轮询机制
---
JS的事件轮询机制用于处理事件和回调函数，让单线程JS可以完成多个任务，完成异步编程

事件轮询机制由事件循环执行 event loop。分为宏任务和微任务。宏任务包括setTimeOut、setInterval、setImmediate这种耗时较长的，微任务包括Promise、MutationObserver等紧急事件。在当前宏任务执行完毕以后会查询微任务队列，并将微任务全部执行完毕，再进行下一个宏任务。
顺序是：
1.在当前宏任务里执行同步任务，直到遇到下一个宏任务或者微任务。
2.如果是宏任务加入宏任务队列，继续下面的同步代码。
3.如果是微任务加入微任务队列，继续下面的同步代码。
4.当前宏任务执行完毕以后，查询微任务队列是否有任务，如果有就执行到全部完毕，查询宏任务队列任务，有就执行。
5.当前事件轮询结束，等待下一次事件触发。

轮询机制提供了一种插队机制。
本质上是一种单线程操作，并不能同时完成两个操作，因此要尽量避免长时间使用同步代码，使用异步代码避免代码阻塞，保证应用的性能和响应速度


JS事件轮询机制是js实现异步编程的核心，而nodejs的事件轮询是实现异步非阻塞IO的核心。

服务器的核心任务就是处理各种 IO 操作，处理后端逻辑，比如：
- 接收 HTTP 请求
- 访问数据库
- 读写文件
- 与其他服务通信
这些操作都涉及 **IO（输入/输出）**。

手写一个事件轮询顺序
```js
console.log("1.同步任务")

setTimeout(()=>{
	console.log("4.宏任务-timeout")
},0) //宏1
Promise.resolve().then(()=>{
	console.log("3.微任务-promise")
}) //微1
Promise.resolve().then(()=>{
	setTimeout(()=>{
		console.log("8.微任务里的宏任务")
	},0) //宏4
}) //微2 

setTimeout(()=>{
	Promise.resolve().then(()=>{
		console.log("5.宏任务里的微任务")
	}).then(()=>{
		console.log("6.宏任务里的微任务2")
	}) //微3、微4
},0) //宏2

function example(){
	console.log("2.同步任务")
}

example()

setTimeout(()=>{
	console.log("7.宏任务")
},0) //宏3
```