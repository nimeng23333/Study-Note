---
title: 浏览器安全
---
重点：
1.什么是XSS
2.如何防御XSS
3.什么是CSRF
4.如何防御CSRF
# xss攻击
cross site scripting
跨站脚本攻击
攻击者在网站注入恶意代码，让它在浏览器运行，窃取用户信息比如cookie

XSS本质是没有对恶意代码进行过滤，浏览器没法分辨

可以获得页面数据cookie、localStorage、sessionStorage、DOM
DOS攻击，发送合理请求，占用服务器资源，让用户无法访问服务器
破坏页面结构
流量劫持（将链接指向某网站）

攻击类型
存储型、反射型和DOM型

存储型将恶意脚本存在目标服务器上，常用于带有用户数据保存的页面，比如论坛发帖、商品评论、用户私信
反射型式攻击者诱导用户访问带有恶意代码的URL，服务器端接受到数据后处理，然后把带有恶意代码的数据返回浏览器端，浏览器解析后当脚本执行。常见于通过URL传递参数的功能，比如网站搜索、跳转
DOM型式通过修改页面DOM节点完成XSS

与反射型XSS不同，DOM型XSS攻击不涉及服务器端的处理。这种攻击是通过修改页面的DOM环境来实现的，通常是通过在URL中加入恶意代码或者通过其他方式使得页面上的JavaScript代码执行不安全的操作。在DOM型XSS攻击中，恶意脚本是在用户的浏览器端执行的，而不是从服务器端返回。这意味着即使服务器端对输入进行了过滤，也无法防止DOM型XSS攻击，因为攻击发生在客户端

[终于弄懂了dom型xss和反射型xss的区别-CSDN博客](https://blog.csdn.net/hackzkaq/article/details/122940831)

|**特性**|**反射型XSS**|**DOM型XSS**|
|---|---|---|
|**触发位置**|服务器返回的响应中执行|客户端JS修改DOM时执行|
|**是否经过服务器**|✔️ 是|❌ 否|
|**攻击载荷位置**|URL参数（`?query=attack`）|URL片段（`#attack`）|
|**防御重点**|服务器端过滤/编码|前端安全编码|
|**典型漏洞代码**|服务端模板：`<%= userInput %>`|前端JS：`element.innerHTML = ...`|
|**用户交互要求**|需点击恶意链接|访问篡改后的URL即可|

# 如何防御XSS攻击

1.浏览器的执行来预防，1使用纯前端，不用服务器端拼接后返回（不用服务端渲染）2对插入HTML的代码做转义（比如过滤输入的数据，包括' ” < >等字符），过滤输入输出。对DOM型，前端脚本不可靠，对数据获取渲染和字符串拼接的时候对恶意代码进行判断

2.使用CSP内容安全策略，建立白名单，告诉浏览器哪些外部资源可以加载和执行，防止恶意代码注入

3.对敏感信息进行保护，比如cookie使用http-only，使脚本无法获取，或使用验证码。

# 什么是CSRF

跨站请求伪造攻击 cross site request forgery

诱导用户进入第三方网站，该网站向被攻击网站发起跨域请求，如果用户在被攻击网站有登录信息，攻击者可以利用这个登录状态，冒充用户执行操作

本质利用cookie会在同源请求中发送给服务器的特点，实现用户的冒充
它通过伪装成受信任用户的请求，欺骗浏览器去执行攻击者预设的操作，如转账、修改邮箱地址等。如果受害者拥有管理员权限，CSRF攻击甚至可能危及整个网站的安全。

攻击类型：

GET类型：比如在img里构建一个请求，用户打开就自动发起提交
POST类型：构建一个表单，隐藏它，用户进入就自动提交
链接类型：在a标签href属性构建一个请求，诱导用户点击。

# 如何防御CSRF

验证码

同源检测：HTTP头origin或referer判断

token：在请求地址中加入token并验证

对cookie双重验证：因为攻击者只能利用cookie不能接收cookie。服务器在用户访问页面后向请求域名注入一个cookie，内容为随机字符，用户再次发送请求的时候从cookie取出字符串添加到URL参数，服务器对cookie数据和参数中进行对比验证

设置cookie属性的时候设置samesite，限制cookie不能被第三方使用