---
title: 垃圾回收机制
---
1.V8的垃圾回收机制是怎样的

# V8的垃圾回收机制是怎样的
准确式GC
GC garbage collection

分代式垃圾回收机制，将内存堆分为新生代和老生代两部分

1.新生代
对象存活时间较短 采用scavenge GC算法
新生代空间中内存分为两个部分 From 空间和 To空间。From空间快被占满时，对其进行一次算法检查，将存活对象复制到To空间里并进行排序。清除掉From空间的对象，最后将To空间的对象交换到From空间。

2.老生代
老生代中对象一般存活时间长且数量较多，使用两个算法，标记清除算法和标记压缩算法。

经历过两次scavenge GC算法的对象会被移动到老生代里
To空间的对象占比大小超过25%，为了不影响内存分配，会移动到老生代里。

new space / old space / code space / map space / lo space(大对象区) / new lo space / 
ro space(不变对象空间)

在老生代中以下情况会启动标记清楚算法(mark-sweep)
某一个空间没有分块的时候
空间中对象超过一定限制
空间不能保证新生代中对象移到老生代中

在这个过程会遍历堆中所有对象，标记活的对象，标记完成后摧毁没有被标记的对象。
在标记大型对象时可能经理几百毫秒才能完成一次标记，可能会造成性能影响。为了解决，2011年v8将全停顿stop-the-world标记切换到增量标记。在增量标记期间，将工作分为更小的模块，让js应用逻辑和标记间歇执行，不至于让应用出现停顿。
在2018年GC技术又有了突破，并发标记，允许GC扫描和标记对象时运行JS应用。

清楚对象以后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动标记压缩算法。将活对象向一端移动，直到所有对象都移动完成后清理掉不需要的内存。