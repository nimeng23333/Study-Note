---
title: 浏览器同源策略
---
重点
1.什么是同源策略
2.如何解决跨越问题

**跨域**是浏览器行为，不是服务器行为。 实际上，请求已经到达服务器了，只不过在回来的时候被浏览器限制了。就像Python他可以进行抓取数据一样，不经过浏览器而发起请求是可以得到数据，想到通过Nginx的反向代理来解决跨域问题。

# 什么是同源策略

浏览器自带的安全策略。协议（http、https）、端口（80、81等）、域名三个相同才能访问
有一个不相同，浏览器禁止加载或执行与自身不同域的脚本

为了保证用户信息安全，防止恶意网站窃取数据

主要限制了三方面：
当下域不能访问其他域的cookie、localStorage、indexedDB
当下域的js脚本不能操作其他域的DOM
当下域的ajax无法发送跨域请求

只是对js脚本的一种限制，并不是对浏览器的限制，一般对img、script脚本的请求都不会有跨域限制。

缺少同源策略浏览器很容易收到XSS、CSFR等攻击

# 如何解决跨域问题

当我们的前端页面部署在一个域名（比如：http://frontend.com）下，而后端接口却在另一个域名（比如：http://backend.com）上时，浏览器出于安全考虑，会阻止前端页面直接向不同源的后端接口发起请求，这就产生了跨域问题。
在前后端不分离的时候基本没有跨域问题

1.CORS
2.JSONP
3.postMessage跨域
4.Nginx代理
5.nodejs中间件代理，原理与Nginx相同
6.document.domain + iframe跨域
7.local.hash + iframe跨域
8.window.name + iframe跨域
9.webSocket跨域

广义跨域包含三种：1.跳转，包括a标签、重定向。2.资源嵌入，link、frame、img等标签，及样式用background:url()等外链。3.脚本请求，浏览器存储数据读取、dom和js对象跨域操作、js发起的ajax请求。
第三种通常有跨域问题

侠义跨域是浏览器同源策略限制的一类请求场景
cookie、localStorage、indexedDB无法读取
dom和js对象无法获取和操作
ajax请求无法发送

1.CORS 
cross origin resources sharing
前后端分离、接口兼容多种客户端
是W3C标准，后端只需要在响应头加几个字段，告诉浏览器这个接口我允许谁访问

CORS需要服务器和客户端都支持，关键是服务器

分为简单请求和非简单请求
简单请求：
1.请求方法：
GET HEAD POST
2.HTTP头不超出以下字段：
Accept
Accept-language
Content-Language
Last-Event-ID
Content-type: 只限于application/x-www-from-urlencoded（表单默认提交数据格式）、multipart/form-data（表单中文件上传）、text/plain（纯文本）

简单请求浏览器直接发送请求并在响应中检查CORS头部：
Access-Control-Allow-Origin
Access-Control-Allow-Credentials：是否发送凭证（比如cookie）
Access-Control-Expose-Headers：哪些头部可以作为响应被访问

复杂请求:
先发送一个预检请求OPTIONS包含
Origin
Access-Control-Request-Method：表示实际请求将用的方法
Access-Control-Request-Headers：实际请求将包含的自定义头部

服务器收到请求后返回一个响应，包含以下头部字段
Access-Control-Allow-Origin
Access-Control-Allow-Method
Access-Control-Allow-Headers
Access-Control-Allow-Credentials
Access-Control-Expose-Headers
Access-Control-Max-Age：预检结果可被缓存的时间

预检通过将会发送实际请求

通常跨域请求不会发送cookie，需要设置withCredentials

2.JSONP JSON with padding
利用script标签没有跨域限制
通过script标签src属性发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数，返回浏览器，浏览器解析，从而拿到callback函数返回的数据

只支持get方法，不安全，可能受XSS攻击

3.postMessage
HTML5中XMLHTTPRequest Level2里的API，是为数不多的跨域操作的window属性之一
可以解决：
页面和其新打开的窗口的数据传递
多窗口的消息传递
页面与iframe消息传递
上面三个场景的数据传递

在web项目中通过iframe嵌入另一个第三方web项目，第三方web项目里点击某个按钮要实时调用web项目的全局函数打开某个全局弹窗或者进行路由跳转，这时候两个项目存在了数据交互，显然违反了同源策略，在HTML5标准引入的window对象下的postMessage方法，可以允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递


用法
targetWindow.postMessage(data,origin)

**targetWindow:**  
目标窗口的引用，比如执行`window.open`返回的窗口对象、打开当前窗口的引用`window.opener`、iframe的contentWindow属性，或者是命名过或数值索引的`window.frames`

**data**： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。

**origin**： 协议+主机+端口号，也可以设置为`"*"`，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为"/"。

基本原理是通过postMessage来发送跨文档信息，使用message来进行监听，当收到跨文档信息后，会触发message事件

[iframe跨域通信(postMessage)transfer：可选参数，高级用法，这里不作讨论，是一串和message - 掘金](https://juejin.cn/post/6844904120680185869)

4.nginx代理
实质和CORS原理一样，通过配置文件设置响应头

[一个小故事彻底讲懂Nginx设置反向代理解决跨域问题----初学者必看_nginx反向代理跨域-CSDN博客](https://blog.csdn.net/weixin_72975727/article/details/138358438)

5.nodejs中间件
代理服务器实现数据转发，也可以通过设置cookieDomainRewrite参数修改响应头中的cookie中的域名

6.document.domain + ifame
仅限主域相同，子域不同的跨域场景

父窗口 `domain.com/a.html`

```html
<iframe id="iframe" src="http://child.domain.com/b.html"></iframe>
<script>
    document.domain = 'domain.com';
    var user = 'admin';
</script>
```

子窗口`child.domain.com/a.html`
```html
<script>
	document.domain = "domain.com"
	//获取父窗口变量
	console.log('get js data from parent ---> ' + window.parent.user);
</script>
```

7.location.hash + iframe
实现原理：a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。

具体实现：A域：a.html -> B域：b.html -> A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。

8.window.name + iframe

9.WebSocket协议跨域

WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。

原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。