---
title: 浏览器事件机制
---
1.事件是什么？事件模型？
2.对事件委托的理解
3.事件委托的使用场景
4.对事件循环的理解
5.宏任务和微任务分别有哪些
6.Node中Event Loop和浏览器中的有什么区别？process.nexttick执行顺序

# 事件是什么？事件模型？
事件是用户操作网页时候的交互动作，click，move
也可以是文档加载、窗口滚动、大小调整

事件被封装成一个event对象，包含相关信息和可以对事件进行的操作

三种事件模型
DOM0级事件模型（原始事件模型）、IE事件模型（基本不用）、DOM2级事件模型（标准事件模型）

DOM0级模型不会传播，没有事件流的概念，可以在网页中直接监听，也可以js属性监听。所有浏览器都兼容，直接在dom对象上注册事件名称
`<input type = "button" onclick = "function()">`

```js
var btn = document.getElementById("btn");
btn.onclick = fun;
```
绑定速度快，只支持冒泡，不支持捕获，同一个类型事件只能绑定一次

DOM2级模型有事件流
捕获阶段、目标阶段、冒泡阶段
addEventListener

IE模型
两个过程，事件处理阶段和冒泡阶段
attachEvent添加

防止事件冒泡：event.stopPropagation()

# 事件委托的理解

利用了冒泡机制，冒泡过程中会传到父节点，因此可以把子节点监听函数绑定在父节点上。由父节点统一处理，称为事件委托。

可以减少内存消耗、实现动态绑定

减少内存消耗：
如果一个列表，有大量列表项，在点击列表项的时候响应一个事件，每一个列表项都绑定对内存消耗很大，最好的就是绑定在父元素，然后执行事件的时候再判断目标元素

动态绑定：
通过ajax或用户操作动态增加或减少列表项目，每次改变如果都重新给元素绑定，给删掉的解绑很麻烦，动态绑定可以减少很多重复工作。

局限性：
focus、blur没有冒泡机制
mousemove、mouseout也不适合

影响页面性能要素：
元素中绑定事件委托次数
点击的最底层元素到绑定元素之间的DOM层数。

只在必要场景使用
ajax局部刷新区域
减少绑定层级，不在body上绑定
减少绑定次数，将多个事件合并到一次事件委托中，回调函数来派发

# 事件委托使用场景

click、mousedown、mouseup、keydown、keyup、keypress

# 对事件循环的理解
event loop
执行同步代码，这属于宏任务
执行完所有同步代码，执行栈为空，查询是否有异步代码
执行所有微任务，完成后如有必要会渲染页面
再去执行宏任务队列中的任务

# 宏任务和微任务分别有哪些

微任务：promise回调、node中的process.nextTick、对DOM变化监听的MutationObserver
宏任务：script脚本、setTimeout、setInterval、setImmediate、I/O操作、UI渲染

# node中的event loop和浏览器的有什么不同？process.nextTick执行顺序？

完全不同。

node中的event loop分为6个阶段
timer（执行setTimeout、setInterval的回调）
io callbacks（处理上一轮未执行的IO回调）
idle/prepare（node内部使用）
poll(轮询，获取新IO事件，适当条件node可能阻塞)
check（执行setImmediate回调）
close callback
按照顺序反复运行

**浏览器环境下，microtask 的任务队列是每个 macrotask 执行完之后执行。而在 Node.js 中，microtask 会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行 microtask 队列的任务**。

node里的process.nextTick独立于event loop，有个独立的列表，在每个阶段完成后，如果存在nextTick队列，就会清空队列所有回调函数，并比其他微任务都先执行。

[理解浏览器与Nodejs中的event loop | Mei's Blog](https://happy-mei.github.io/posts/event-loop/)

在 Node.js 中，**整个 script 脚本就是事件循环的第一个宏任务**，它在事件循环开始前就执行完毕，然后才进入异步任务调度阶段。
## Node.js 的执行流程简化如下：

1. **初始化阶段**：
    
    - 加载模块
        
    - 执行整个脚本（也就是你的同步代码）
        
    - 注册异步任务（如 `setTimeout`、`fs.readFile` 等）
        
2. **事件循环开始**：
    
    - 才会进入各个阶段：`timers` → `pending callbacks` → `poll` → `check` → `close callbacks`


在 Node.js 中，事件循环**不会像浏览器那样遇到“其他脚本”插入执行的情况**，因为 Node.js 的执行模型是**单入口、单线程、模块化加载**的。

1. **单入口执行**

Node.js 是通过命令行执行一个 `.js` 文件作为入口点，比如：


```
node app.js
```

这个文件就是整个程序的起点，Node 会**先执行所有同步代码**，然后才进入事件循环处理异步任务。

2. **模块化加载而非动态插入**

在浏览器中，可能会遇到：

```
<script src="a.js"></script>
<script src="b.js"></script>
```

这会导致多个脚本在不同时间点插入执行，甚至可以动态插入 `<script>` 标签。但在 Node.js 中，所有模块都是通过 `require()` 或 `import` 显式加载的：


```
const utils = require('./utils.js');
```

这些模块在加载时会立即执行其顶层代码，但它们仍然属于**当前主线程的同步执行流程**，不会打断事件循环或插入新的“脚本阶段”。

3. **事件循环是由 libuv 驱动的底层机制**

Node.js 的事件循环由 C++ 层的 libuv 实现，它控制着异步任务的调度。一旦进入事件循环，所有任务都是从注册好的队列中调度执行，不会突然“插入”新的脚本。