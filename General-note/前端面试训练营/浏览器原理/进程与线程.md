---
title: 进程与线程
---
重点：
1.进程和线程的区别
2.进程之间的通信方式
3.死锁产生的原因，如何解决死锁问题

# 进程和线程的区别

进程可以看作独立应用，线程不行
资源：进程是cpu资源分配最小单位（能拥有资源和独立运行的最小单位）；线程是CPU调度最小单位（线程建立在进程基础上的一次程序运行单位，一个进程可以有多个线程）
通信：线程间可以直接共享进程中的资源，而进程通讯需要借助进程间通信
调度：进程切换比线程切换开销大。
系统开销：系统创建或撤销进程时涉及到分配或回收资源，开销远大于线程开销。同理切换进程涉及到当前执行进程CPU环境和各种各样状态的保存及新调度进程状态的设置。

# 进程之间的通信方式

IPC interProcess Communication
进程间信息交换

1.管道
管道本质在内存中开辟了一个缓冲区，缓冲区与管道文件相关联。
匿名管道只能在有亲缘关系的进程中通信，而且是单向的，如果想双向通讯就建立两个管道

管道依赖于文件系统，生命周期跟随进程，面向字节流的服务，提供了同步机制

命名管道FIFO first in first out先进先出
不存在亲缘关系的进程只要能访问路径就能进行通信

生命周期跟随文件系统

2.消息队列
一个消息的列表，用户可以在消息队列添加消息、读取消息。
本质是存在内存中的消息链表，消息本质是用户自定义的数据结构

允许一个或多个进程写入或读取
可以实现随机查询，不一定先进先出
不需要另一个进程在消息队列上等待，就可以写入消息，与管道不同，管道在写入操作之前必须有读进程存在

生命周期随内核，没有释放消息队列或关闭操作系统，消息队列会一直存在。

每个数据块有最大长度限制

如果频繁发生进程间通信行为，内核和进程需要频繁读取队列中的数据，造成频繁的系统调用，需要花费时间

3.共享内存
不相干进程将同一段物理内存连接到它们各自地址空间
最快的IPC方式

4.信号量和PV操作

信息传递优于共享内存，因为无需避免冲突，共享内存可能存在冲突，多个进程同时修改一个共享内存，先写的内容会被后来的覆盖

解决这个问题靠信号量，实现进程之间的互斥与同步
比如信号量初始为1，a进程访问内存1的时候信号量设为0，进程b看到0就知道已有进程在访问。

并不是用来传输进程之间的真正通信内容，单由于传输信号量，也被纳入进程通信的范畴，为低级通信。

p操作：信号量-1，表示申请一个资源，信号量大于0表示有资源可以使用
v操作：信号量+1，表示释放一个资源，如果释放后信号量小于等于0，表示有进程在等待资源，需要唤醒等待的进程让它运行。

信号量可以大于等于小于0，申请资源的时候小于等于0进程会进行等待，等到有v操作后唤醒

5.信号
唯一异步通信机制
在任何时候发送信号给某个进程，通过发送指定信号来通知进程某个异步事件的发送，迫使进程执行信号处理程序，处理完成后进程恢复
用户、内核、进程都可以生成和发送信号
硬件来源和软件来源。
硬件来源比如用键盘输入组合键发送信号，比如alt+F4产生发送终止进程信号

6.Socket
跨网络与不同主机上的进程通信（当然也能完成同主机通信）
例如发起http请求，服务器返回对应数据，就是采用socket通信
socket是网络通信的基石，支持TCP/IP协议的网络通信的基本操作单元。网络通信过程中端点的抽象表示，包含网络通信必须的五种信息：协议、本地主机IP地址、本地进程协议端口、远地主机IP地址、远地进程的协议端口

本质是一个编程接口API，对TCP/IP进行封装

总结：
简单总结一下上面六种 Linux 内核提供的进程通信机制：

1）首先，最简单的方式就是**管道**，管道的本质是存放在内存中的特殊的文件。也就是说，内核在内存中开辟了一个缓冲区，这个缓冲区与管道文件相关联，对管道文件的操作，被内核转换成对这块缓冲区的操作。管道分为匿名管道和有名管道，匿名管道只能在父子进程之间进行通信，而有名管道没有限制。

2）虽然管道使用简单，但是效率比较低，不适合进程间频繁地交换数据，并且管道只能传输无格式的字节流。为此**消息队列**应用而生。消息队列的本质就是存放在内存中的消息的链表，而消息本质上是用户自定义的数据结构。如果进程从消息队列中读取了某个消息，这个消息就会被从消息队列中删除。

3）消息队列的速度比较慢，因为每次数据的写入和读取都需要经过用户态与内核态之间数据的拷贝过程，**共享内存**可以解决这个问题。所谓共享内存就是：两个不同进程的逻辑地址通过页表映射到物理空间的同一区域，它们所共同指向的这块区域就是共享内存。如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。

对于共享内存机制来说，仅在建立共享内存区域时需要系统调用，一旦建立共享内存，所有的访问都可作为常规内存访问，无需借助内核。这样，数据就不需要在进程之间来回拷贝，所以这是最快的一种进程通信方式。

4）共享内存速度虽然非常快，但是存在冲突问题，为此，我们可以使用信号量和 PV 操作来实现对共享内存的互斥访问，并且还可以实现进程同步。

5）**信号**和信号量是完全不同的两个概念！信号是进程通信机制中唯一的异步通信机制，它可以在任何时候发送信号给某个进程。通过发送指定信号来通知进程某个异步事件的发送，以迫使进程执行信号处理程序。信号处理完毕后，被中断进程将恢复执行。用户、内核和进程都能生成和发送信号。

6）上面介绍的 5 种方法都是用于同一台主机上的进程之间进行通信的，如果想要跨网络与不同主机上的进程进行通信，就需要使用 **Socket** 通信。另外，Socket 也能完成同主机上的进程通信。

# 死锁产生的原因？如何解决死锁问题？
多个进程在运行过程因资源争夺造成的僵局，当进程处于这种僵持状态如果没有外力，将无法向前推进。

产生原因：1.资源竞争2.进程间推进顺序非法

产生死锁四个必要条件：
1.互斥：一个资源一段时间内只能被一个进程占用（写操作基本都是）
2.请求和保持：进程被阻塞后对持有资源不放
3.不可剥夺：必须等进程结束主动释放资源，不能剥夺
4.环路等待：进程-资源环路

预防死锁：
资源一次性分配（破坏请求条件）
只要有一个资源得不到，也不给这进程其他资源（破坏保持条件）
可剥夺资源（破坏不可剥夺条件）
资源有序分配（破坏环路）

预防死锁的几种策略会严重损害系统性能，在避免死锁时要施加较弱限制。最具有代表性避免死锁的算法是银行家算法。